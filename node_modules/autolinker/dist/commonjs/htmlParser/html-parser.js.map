{"version":3,"sources":["../src/htmlParser/html-parser.ts"],"names":[],"mappings":"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","file":"html-parser.js","sourcesContent":["import { splitAndCapture } from \"../utils\";\nimport { CommentNode } from \"./comment-node\";\nimport { ElementNode } from \"./element-node\";\nimport { EntityNode } from \"./entity-node\";\nimport { TextNode } from \"./text-node\";\nimport { HtmlNode } from \"./html-node\";\n\n/**\n * @private\n * @property {RegExp} htmlRegex\n *\n * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n *\n * Capturing groups:\n *\n * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n * 2. If it is an end tag, this group will have the '/'.\n * 3. If it is a comment tag, this group will hold the comment text (i.e.\n *    the text inside the `&lt;!--` and `--&gt;`.\n * 4. The tag name for a tag without attributes (other than the &lt;!DOCTYPE&gt; tag)\n * 5. The tag name for a tag with attributes (other than the &lt;!DOCTYPE&gt; tag)\n */\nconst htmlRegex = (function() {\n\tlet commentTagRegex = /!--([\\s\\S]+?)--/,\n\t\ttagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,\n\t\tattrNameRegex = /[^\\s\"'>\\/=\\x00-\\x1F\\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char\n\t\tattrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/, // double quoted, single quoted, or unquoted attribute values\n\t\toptionalAttrValueRegex = '(?:\\\\s*?=\\\\s*?' + attrValueRegex.source + ')?'; // optional '=[value]'\n\n\tconst getNameEqualsValueRegex = (group: number) => {\n\t\treturn '(?=(' + attrNameRegex.source + '))\\\\' + group + optionalAttrValueRegex;\n\t};\n\n\treturn new RegExp( [\n\t\t// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t'(?:',\n\t\t\t'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag\n\n\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t'(?:',\n\t\t\t\t\t'\\\\s+',  // one or more whitespace chars before an attribute\n\n\t\t\t\t\t// Either:\n\t\t\t\t\t// A. attr=\"value\", or\n\t\t\t\t\t// B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t\t\t\t// *** Capturing Group 2 - Pseudo-atomic group for attrNameRegex\n\t\t\t\t\t'(?:', getNameEqualsValueRegex(2), '|', attrValueRegex.source + ')',\n\t\t\t\t')*',\n\t\t\t'>',\n\t\t')',\n\n\t\t'|',\n\n\t\t// All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n\t\t'(?:',\n\t\t\t'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.\n\t                 // *** Capturing Group 3: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n\n\t\t\t\t'(?:',\n\t\t\t\t\tcommentTagRegex.source,  // *** Capturing Group 4 - A Comment Tag's Text\n\n\t\t\t\t\t'|',\n\n\t\t\t\t\t// Handle tag without attributes.\n\t\t\t\t\t// Doing this separately from a tag that has attributes\n\t\t\t\t\t// to fix a regex time complexity issue seen with the\n\t\t\t\t\t// example in https://github.com/gregjacobs/Autolinker.js/issues/172\n\t\t\t\t\t'(?:',\n\t\t\t\t\t\t// *** Capturing Group 5 - The tag name for a tag without attributes\n\t\t\t\t\t\t'(' + tagNameRegex.source + ')',\n\n\t\t\t\t\t\t'\\\\s*/?',  // any trailing spaces and optional '/' before the closing '>'\n\t\t\t\t\t')',\n\n\t\t\t\t\t'|',\n\n\t\t\t\t\t// Handle tag with attributes\n\t\t\t\t\t// Doing this separately from a tag with no attributes\n\t\t\t\t\t// to fix a regex time complexity issue seen with the\n\t\t\t\t\t// example in https://github.com/gregjacobs/Autolinker.js/issues/172\n\t\t\t\t\t'(?:',\n\t\t\t\t\t\t// *** Capturing Group 6 - The tag name for a tag with attributes\n\t\t\t\t\t\t'(' + tagNameRegex.source + ')',\n\n\t\t\t\t\t\t'\\\\s+',  // must have at least one space after the tag name to prevent ReDoS issue (issue #172)\n\n\t\t\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t\t'(?:\\\\s+|\\\\b)',        // any number of whitespace chars before an attribute. NOTE: Using \\s* here throws Chrome into an infinite loop for some reason, so using \\s+|\\b instead\n\t\t\t\t\t\t\t// *** Capturing Group 7 - Pseudo-atomic group for attrNameRegex\n\t\t\t\t\t\t\tgetNameEqualsValueRegex(7),  // attr=\"value\" (with optional =\"value\" part)\n\t\t\t\t\t\t')*',\n\n\t\t\t\t\t\t'\\\\s*/?',  // any trailing spaces and optional '/' before the closing '>'\n\t\t\t\t\t')',\n\t\t\t\t')',\n\t\t\t'>',\n\t\t')'\n\t].join( \"\" ), 'gi' );\n} )();\n\n\n/**\n * @private\n * @property {RegExp} htmlCharacterEntitiesRegex\n *\n * The regular expression that matches common HTML character entities.\n *\n * Ignoring &amp; as it could be part of a query string -- handling it separately.\n */\nconst htmlCharacterEntitiesRegex = /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi;\n\n\n/**\n * @class Autolinker.htmlParser.HtmlParser\n * @extends Object\n *\n * An HTML parser implementation which simply walks an HTML string and returns an array of\n * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n *\n * Autolinker uses this to only link URLs/emails/mentions within text nodes, effectively ignoring / \"walking\n * around\" HTML tags.\n */\nexport class HtmlParser {\n\n\t/**\n\t * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}\n\t * to represent the HTML structure of the input string.\n\t *\n\t * @param {String} html The HTML to parse.\n\t * @return {Autolinker.htmlParser.HtmlNode[]}\n\t */\n\tparse( html: string ) {\n\t\tlet currentResult: RegExpExecArray | null,\n\t\t    lastIndex = 0,\n\t\t    textAndEntityNodes: HtmlNode[],\n\t\t    nodes: HtmlNode[] = [];  // will be the result of the method\n\n\t\twhile( ( currentResult = htmlRegex.exec( html ) ) !== null ) {\n\t\t\tlet tagText = currentResult[ 0 ],\n\t\t\t    commentText = currentResult[ 4 ], // if we've matched a comment\n\t\t\t    tagName = currentResult[ 1 ] || currentResult[ 5 ] || currentResult[ 6 ],  // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\")\n\t\t\t    isClosingTag = !!currentResult[ 3 ],\n\t\t\t    offset = currentResult.index,\n\t\t\t    inBetweenTagsText = html.substring( lastIndex, offset );\n\n\t\t\t// Push TextNodes and EntityNodes for any text found between tags\n\t\t\tif( inBetweenTagsText ) {\n\t\t\t\ttextAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, inBetweenTagsText );\n\t\t\t\tnodes.push.apply( nodes, textAndEntityNodes );\n\t\t\t}\n\n\t\t\t// Push the CommentNode or ElementNode\n\t\t\tif( commentText ) {\n\t\t\t\tnodes.push( this.createCommentNode( offset, tagText, commentText ) );\n\t\t\t} else {\n\t\t\t\tnodes.push( this.createElementNode( offset, tagText, tagName, isClosingTag ) );\n\t\t\t}\n\n\t\t\tlastIndex = offset + tagText.length;\n\t\t}\n\n\t\t// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n\t\tif( lastIndex < html.length ) {\n\t\t\tlet text = html.substring( lastIndex );\n\n\t\t\t// Push TextNodes and EntityNodes for any text found between tags\n\t\t\tif( text ) {\n\t\t\t\ttextAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, text );\n\n\t\t\t\t// Note: the following 3 lines were previously:\n\t\t\t\t//   nodes.push.apply( nodes, textAndEntityNodes );\n\t\t\t\t// but this was causing a \"Maximum Call Stack Size Exceeded\"\n\t\t\t\t// error on inputs with a large number of html entities.\n\t\t\t\ttextAndEntityNodes.forEach( node => nodes.push( node ) );\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\n\t/**\n\t * Parses text and HTML entity nodes from a given string. The input string\n\t * should not have any HTML tags (elements) within it.\n\t *\n\t * @private\n\t * @param {Number} offset The offset of the text node match within the\n\t *   original HTML string.\n\t * @param {String} text The string of text to parse. This is from an HTML\n\t *   text node.\n\t * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to\n\t *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and\n\t *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n\t */\n\tparseTextAndEntityNodes( offset: number, text: string ) {\n\t\tlet nodes: HtmlNode[] = [],\n\t\t    textAndEntityTokens = splitAndCapture( text, htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array\n\n\t\t// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n\t\t// For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the\n\t\t//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n\t\tfor( let i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {\n\t\t\tlet textToken = textAndEntityTokens[ i ],\n\t\t\t    entityToken = textAndEntityTokens[ i + 1 ];\n\n\t\t\tif( textToken ) {\n\t\t\t\tnodes.push( this.createTextNode( offset, textToken ) );\n\t\t\t\toffset += textToken.length;\n\t\t\t}\n\t\t\tif( entityToken ) {\n\t\t\t\tnodes.push( this.createEntityNode( offset, entityToken ) );\n\t\t\t\toffset += entityToken.length;\n\t\t\t}\n\t\t}\n\t\treturn nodes;\n\t}\n\n\n\t/**\n\t * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.\n\t *\n\t * @private\n\t * @param {Number} offset The offset of the match within the original HTML\n\t *   string.\n\t * @param {String} tagText The full text of the tag (comment) that was\n\t *   matched, including its &lt;!-- and --&gt;.\n\t * @param {String} commentText The full text of the comment that was matched.\n\t */\n\tcreateCommentNode( offset: number, tagText: string, commentText: string ) {\n\t\treturn new CommentNode( {\n\t\t\toffset : offset,\n\t\t\ttext   : tagText,\n\t\t\tcomment: commentText.trim()\n\t\t} );\n\t}\n\n\n\t/**\n\t * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n\t *\n\t * @private\n\t * @param {Number} offset The offset of the match within the original HTML\n\t *   string.\n\t * @param {String} tagText The full text of the tag (element) that was\n\t *   matched, including its attributes.\n\t * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would\n\t *   be passed to this method as \"img\".\n\t * @param {Boolean} isClosingTag `true` if it's a closing tag, false\n\t *   otherwise.\n\t * @return {Autolinker.htmlParser.ElementNode}\n\t */\n\tcreateElementNode( offset: number, tagText: string, tagName: string, isClosingTag: boolean ) {\n\t\treturn new ElementNode( {\n\t\t\toffset  : offset,\n\t\t\ttext    : tagText,\n\t\t\ttagName : tagName.toLowerCase(),\n\t\t\tclosing : isClosingTag\n\t\t} );\n\t}\n\n\n\t/**\n\t * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n\t *\n\t * @private\n\t * @param {Number} offset The offset of the match within the original HTML\n\t *   string.\n\t * @param {String} text The text that was matched for the HTML entity (such\n\t *   as '&amp;nbsp;').\n\t * @return {Autolinker.htmlParser.EntityNode}\n\t */\n\tcreateEntityNode( offset: number, text: string ) {\n\t\treturn new EntityNode( { offset, text } );\n\t}\n\n\n\t/**\n\t * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n\t *\n\t * @private\n\t * @param {Number} offset The offset of the match within the original HTML\n\t *   string.\n\t * @param {String} text The text that was matched.\n\t * @return {Autolinker.htmlParser.TextNode}\n\t */\n\tcreateTextNode( offset: number, text: string ) {\n\t\treturn new TextNode( { offset, text } );\n\t}\n\n}\n"]}